/*
    The Scopes Compiler Infrastructure
    This file is distributed under the MIT License.
    See LICENSE.md for details.
*/

#include "symbol_enum.inc"
#include "ppmacro.inc"

#include "hash.hpp"

#include <string.h>
#include <assert.h>
#include <iostream>
#include <unordered_set>
#include <stdio.h>
#include <vector>
#include <assert.h>

#define NEWMODE

using namespace std;

static std::unordered_set<uint64_t> seen_hashes;

void write_entry(const char *symbol, const char *str) {
    using namespace scopes;
    auto len = strlen(str);
    auto id = len?hash_bytes(str, len):0;
#ifdef NEWMODE
    cout << "    " << symbol << " = " << id << "ull, /*" << str << "*/" << endl;
#else
    cout << "    " << symbol << ", /*" << str << "*/" << endl;
#endif
    if (seen_hashes.count(id)) {
        assert(false && "duplicate hash");
    }
    seen_hashes.insert(id);
}

int main(int argc, char *argv[]) {
  if (argc > 1) {
    const char* prefix = argv[1];
    int prefixlen = strlen(prefix);
    std::vector<const char*> paths;
    std::vector<size_t> sizes;

    for (int i = 2; i < argc; ++i)
    {
      paths.push_back(argv[i] + prefixlen);
      sizes.push_back(0);
    }
    cout << "// this file is autogenerated by gensyms.cpp" << endl;
    cout << "#ifndef SCOPES_INTERNALIZED_FILES_HPP" << endl;
    cout << "#define SCOPES_INTERNALIZED_FILES_HPP" << endl;
    cout << endl;
    cout << "#include <stdint.h>" << endl;
    cout << endl;
    cout << "namespace scopes {" << endl;

    for (int i = 0; i < paths.size(); ++i)
    {
      FILE* f = fopen((std::string(prefix) + paths[i]).c_str(), "rb");
      if (f)
      {
        int total = 0;
        const int BLOCK_SIZE = 2048;
        char buf[BLOCK_SIZE+1];
        //char process[BLOCK_SIZE * 5];

        cout << endl;
        cout << "const char internalfile_" << i << "[] = { " << '"';

        while (!feof(f))
        {
          int count = fread(buf, 1, BLOCK_SIZE, f);
          buf[count] = 0;
          total += count;
          const char* found = buf;
          const char* prev = buf;
          while (found = strpbrk(found, "\"\n\r\t\v\b\f\\"))
          {
            fwrite(prev, 1, (found - prev), stdout);
            cout << '\\';
            switch (*found)
            {
            case '\"': cout << '"'; break;
            case '\n': cout << 'n'; break;
            case '\r': cout << 'r'; break;
            case '\t': cout << 't'; break;
            case '\v': cout << 'v'; break;
            case '\b': cout << 'b'; break;
            case '\f': cout << 'f'; break;
            case '\\': cout << '\\'; break;
            default: assert(false);
            }

            prev = ++found;
          }
          auto end = buf + count;
          fwrite(prev, 1, end - prev, stdout);

          //for (int j = 0; j < count; ++j)
          //  sprintf(process + j * 5, "0x%0.2hhX,", buf[j]);
          //fwrite(process, 5, count, stdout);
        }

        fclose(f);

        cout << '"' << " };" << endl;
        sizes[i] = total;
      }
    }

    cout << "static const char* internalfile_list" << "[] = { ";
    for (int i = 0; i < paths.size(); ++i)
      cout << (!i ? "" : ", ") << "internalfile_" << i;
    cout << " };" << endl;

    cout << "static size_t internalfile_sizes" << "[] = { ";
    for (int i = 0; i < sizes.size(); ++i)
      cout << (!i ? "" : ", ") << sizes[i];
    cout << " };" << endl;

    cout << "static const char* internalfile_paths" << "[] = { ";
    for (int i = 0; i < sizes.size(); ++i)
      cout << (!i ? "" : ", ") << '"' << paths[i] << '"';
    cout << " };" << endl;

    cout << endl;
    cout << "} // namespace scopes" << endl;
    cout << endl;
    cout << "#endif // SCOPES_INTERNALIZED_FILES_HPP" << endl;
    return 0;
  }

    cout << "// this file is autogenerated by gensyms.cpp" << endl;
    cout << "#ifndef SCOPES_KNOWN_SYMBOLS_HPP" << endl;
    cout << "#define SCOPES_KNOWN_SYMBOLS_HPP" << endl;
    cout << endl;
    cout << "namespace scopes {" << endl;
    cout << endl;
    cout << "enum KnownSymbol : unsigned long long {" << endl;

#define T(sym, name) \
    write_entry( #sym, name);
    SCOPES_SYMBOLS()
#undef T

#define T(sym) \
    write_entry(SCOPES_STRINGIFY(SYM_SPIRV_StorageClass ## sym), #sym);
    B_SPIRV_STORAGE_CLASS()
#undef T

#define T(sym) \
    write_entry(SCOPES_STRINGIFY(SYM_SPIRV_BuiltIn ## sym), "spirv." #sym);
    B_SPIRV_BUILTINS()
#undef T
#define T(sym) \
    write_entry(SCOPES_STRINGIFY(SYM_SPIRV_ExecutionMode ## sym), #sym);
    B_SPIRV_EXECUTION_MODE()
#undef T
#define T(sym) \
    write_entry(SCOPES_STRINGIFY(SYM_SPIRV_Dim ## sym), #sym);
    B_SPIRV_DIM()
#undef T
#define T(sym) \
    write_entry(SCOPES_STRINGIFY(SYM_SPIRV_ImageFormat ## sym), #sym);
    B_SPIRV_IMAGE_FORMAT()
#undef T
#define T(sym) \
    write_entry(SCOPES_STRINGIFY(SYM_SPIRV_ImageOperand ## sym), #sym);
    B_SPIRV_IMAGE_OPERAND()
#undef T

#ifndef NEWMODE
    cout << "    SYM_Count," << endl;
#endif
    cout << "};" << endl;
    cout << endl;
    cout << "} // namespace scopes" << endl;
    cout << endl;
    cout << "#endif // SCOPES_SYMBOL_ENUM_HPP" << endl;
    return 0;
}
